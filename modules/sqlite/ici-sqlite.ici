/*
 *  sqlite module.
 *  Copyright (C) 2019 A.Newman.
 */

/*
 * array = sqlite.table_names(db)
 *
 * Return an array containing the names of the (user) tables in the database.
 */
extern table_names(db)
{
    rows := db:exec("select tbl_name from sqlite_master where type = 'table' order by tbl_name asc");
    names := array();
    forall (row in rows)
    {
        push(names, row.tbl_name);
    }
    return names;
}

/*
 * string = sqlite.primary_key(db, table)
 *
 * Returns the name of the primary key column in the named table.
 * If the table has no defined primary key the name of the first
 * column is returned.
 */
extern primary_key(db, table)
{
    rows := db:exec(sprintf("pragma table_info(%s)", table));
    forall (col in rows)
    {
        if (col.pk)
        {
            return col.name;
        }
    }
    return rows[0].name;
}

/*
 * string = sqllite.type_for(any)
 *
 * Returns the SQL type used to represent _any_ or raises
 * an error if _any_ has no corresponding SQL type.
 */
extern type_for(any)
{
    switch (t := typeof(any))
    {
    case "float":
        return "real";
    case "int":
        return "integer";
    case "mem":
        return "blob";
    case "string":
        return "text";
    default:
        fail(sprintf("%s: no appropriate SQL type", t));
    }
}

/*
 * string = sqlite.as_string(any)
 *
 * Returns an SQL literal representation of the given value.
 */
extern as_string(any)
{
    switch (typeof(any))
    {
    case "NULL":
        return "NULL";
    case "string":
        return "'" + any + "'";
    default:
        return string(any);
    }
}

/*
 * any = sqlite.run(string, database [, error_handler])
 *
 * Execute the given SQL statements using the supplied database
 * using the supplied error_handler, if any, to handle errors.
 *
 * Note the order of arguments, the string containing the SQL
 * statements is the first argument and the database second.
 * This is unlike other functions that take a database but
 * reads more naturally..."Run. This sql. With this database."
 *
 * If used, error_handler is called with three arguments - the database,
 * the SQL statements and the ICI error string.  If the error function
 * returns NULL (or integer 0) the SQL statement is retried otherwise
 * the call to run returns the result of error_handler as its result.
 *
 * This --topic-- is part of --ici-sqlite-- documentation.
 */
extern run(sql, db, error_handler)
{
    //  The default error handler calls fail() to propogate the error.
    //
    var error_handler = [func (db, stmt, error) { fail(error); }];

    for (;;)
    {
	try
	{
	    return db:exec(sql);
	}
	onerror
	{
	    if (debug())
            {
		printf(stderr, "sqlite: %s\n", error); flush(stderr);
            }
	    if (rc := call(error_handler, array(db, sql, error)))
            {
		return rc;
            }
        }
    }
}


/*
 *  string = sqlite.table_for_map(map)
 *
 *  Returns a string containg an SQL "create table" statement that will
 *  create a table to hold the values held in the map with the map keys,
 *  which must be strings, as column names. I.e. the map is a prototype
 *  entity providing column names along with example column values (to
 *  allows types to be determined).
 */
extern table_for_map(entity, name)
{
    sql := "create table " + name + " (";
    sep := "";
    forall (v, k in entity)
    {
       sql += sprintf("%s%s %s", sep, k, type_for(v));
       sep = ", ";
    }
    return sql + ")";
}

/* ================================================================ */

extern Database = [class

    new(filename, options)
    {
        var options = "c";
        this = this:^new();
        this._filename := filename;
        this._db := open(filename, options);
        this:create_tables();
        return this;
    }

    exec(sql)
    {
        var vargs = [array];
        return call(_db:exec, array(sql) + vargs);
    }

    create_tables()
    {
    }

    insert_entity_sql(table, entity)
    {
        cols := keys(entity);
        sql := "insert into " + table + " (";
        sep := "";
        forall (col in cols)
        {
            sql += sep + col;
            sep = ", ";
        }
        sql = sql + ") values (";
        sep := "";
        forall (col in cols)
        {
            sql += sep + as_string(entity[col]);
            sep = ", ";
        }
        return sql + ")";
    }

    unknown_method(method)
    {
        var vargs = [array];
        parts := split(method, "_");

        // <table>_insert(entity)
        //
        if (len(vargs) == 1 && len(parts) == 2 && parts[1] == "insert")
        {
            return _db:exec(this:insert_entity_sql(parts[0], vargs[0]));
        }

        // get_<table>(id) -> map
        //
        if (len(vargs) == 1 && len(parts) == 2 && parts[0] == "get")
        {
            sql := sprintf
            (
                "select * from %s where %s = %s",
                parts[1],
                primary_key(_db, parts[1]),
                as_string(vargs[0])
            );
            rows := _db:exec(sql);
            switch (len(rows))
            {
            case 0:
                return NULL;
            case 1:
                return rows[0];
            default:
                fail("too many results");
            }
        }

        // get_<table>_by_<column>(value)
        //
        if (len(vargs) == 1 && len(parts) == 4 && parts[0] == "get" && parts[2] == "by")
        {
            sql := sprintf("select * from %s where %s = %s", parts[1], parts[3], as_string(vargs[0]));
            return _db:exec(sql);
        }

        // get_<table>_by_<column>_like(value)
        //
        if (len(vargs) == 1 && len(parts) == 5 && parts[0] == "get" && parts[2] == "by" && parts[4] == "like")
        {
            sql := sprintf("select * from %s where %s like %s", parts[1], parts[3], as_string(vargs[0]));
            return _db:exec(sql);
        }

        printf("sqlite.Database.unknown_method %s", method);
        print(vargs);
        puts("");
    }

];
