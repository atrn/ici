/*
 * string = sqllite.type_for(any)
 *
 * Returns the SQL type used to represent _any_ or raises
 * an error if _any_ has no corresponding SQL type.
 */
extern type_for(v)
{
    switch (t := typeof(v))
    {
    case "float":
        return "real";
    case "int":
        return "integer";
    case "mem":
        return "blob";
    case "string":
        return "text";
    default:
        fail(sprintf("%s: no appropriate SQL type", t));
    }
}

extern as_string(any)
{
    switch (typeof(any))
    {
    case "NULL":
        return "NULL";
    case "string":
        return "'" + any + "'";
    default:
        return string(any);
    }
}

/*
 * any = sqlite.perform(database, string [, error_func])
 *
 * Execute the SQL statements in the given string using the supplied
 * database and call the supplied error_func if any error is reported
 * by the database.
 *
 * error_func() is called with three arguments - the database, the
 * SQL string and the ICI error string.  If the error function returns
 * NULL (or 0) the SQL statement is retried otherwise the call to exec
 * returns the result of error_func().
 *
 * This --topic-- is part of --ici-sqlite-- documentation.
 */
extern perform(db, sql, error_handler)
{
    var error_handler = [func (db, stmt, error) { fail(error); }];

    for (;;)
    {
	try
	{
	    return db:exec(sql);
	}
	onerror
	{
	    if (debug())
            {
		printf(stderr, "sqlite: %s\n", error); flush(stderr);
            }
	    if (rc := call(error_handler, array(db, sql, error)))
            {
		return rc;
            }
        }
    }
}


/*
 *  string = sqlite.table_for_map(map)
 *
 *  Returns a string containg an SQL "create table" statement that will
 *  create a table to hold the values held in the map with the map keys,
 *  which must be strings, as column names. I.e. the map is a prototype
 *  entity providing column names along with example column values (to
 *  allows types to be determined).
 */
extern table_for_map(entity, name)
{
    sql := "create table " + name + " (";
    sep := "";
    forall (v, k in entity)
    {
       sql += sprintf("%s%s %s", sep, k, type_for(v));
       sep = ", ";
    }
    return sql + ")";
}

/* ================================================================ */

extern Database = [class

    new(filename, options)
    {
        var options = "c";
        this = this:^new();
        this._filename := filename;
        this._db := open(filename, options);
        this:create_tables();
        return this;
    }

    exec(sql)
    {
        var vargs = [array];
        return call(_db:exec, array(sql) + vargs);
    }

    create_tables()
    {
    }

    insert_entity_sql(table, entity)
    {
        cols := keys(entity);
        sql := "insert into " + table + " (";
        sep := "";
        forall (col in cols)
        {
            sql += sep + col;
            sep = ", ";
        }
        sql = sql + ") values (";
        sep := "";
        forall (col in cols)
        {
            sql += sep + as_string(entity[col]);
            sep = ", ";
        }
        return sql + ")";
    }

    unknown_method(method)
    {
        var vargs = [array];
        parts := split(method, "_");

        // <table>_insert(entity)
        //
        if (len(vargs) == 1 && len(parts) == 2 && parts[1] == "insert")
        {
            return _db:exec(this:insert_entity_sql(parts[0], vargs[0]));
        }

        // get_<table>_by_<column>(value)
        //
        if (len(vargs) == 1 && len(parts) == 4 && parts[0] == "get" && parts[2] == "by")
        {
            sql := sprintf("select * from %s where %s = %s", parts[1], parts[3], as_string(vargs[0]));
            return _db:exec(sql);
        }

        // get_<table>_by_<column>_like(value)
        //
        if (len(vargs) == 1 && len(parts) == 5 && parts[0] == "get" && parts[2] == "by" && parts[4] == "like")
        {
            sql := sprintf("select * from %s where %s like %s", parts[1], parts[3], as_string(vargs[0]));
            return _db:exec(sql);
        }

        printf("sqlite.Database.unknown_method %s", method);
        print(vargs);
        puts("");
    }

];
