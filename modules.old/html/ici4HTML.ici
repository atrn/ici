/*
 * $Id: ici4HTML.ici,v 1.5 2003/06/09 07:56:50 atrn Exp $
 *
 *
 * HTML element classes for ICI.
 *
 *
 * Copyright (C) A.Newman, 2001.
 *
 */


/*
 * Clean a string making it suitable for output via HTML.
 * This encodes any special characters as HTML entities.
 */
static encode(s)
{
    if (s)
    {
	s = gsub(s, #&#, "&amp;"); // nb. must do this first!
	s = gsub(s, #<#, "&lt;");
	s = gsub(s, #>#, "&gt;");
    }
    return s ? s : "";
}


/*
 * HTML.Element - base class of HTML elements
 *
 * An element is the base unit in the document hierarchy.  An element
 * has a "tag", some attributes (key/value pairs), some body text and
 * a sequence of child elements.  The basic operations on elements are
 * setting its body text, adding child elements, setting attributes and
 * finally generating an HTML representation of an element.
 *
 * The element output operation is implemented in stages.  Each stage
 * is implemented in a separate method allowing derived classes to
 * specialise the behaviour.  Output is separated into "head", "body"
 * and "tail" sections. Output of element attributes is also separated
 * out allowing separate control over attribute output if required.
 *
 * The interface to element output is a single method, "output(file)",
 * that outputs HTML for the element instance to the given file.  This
 * interface can be considered a "protocol".  Any class that implements
 * an "output(file)" method may be used as a child element within an
 * HTML.Element instance.  Presumably the class performs some special
 * action, e.g, a database lookup, and returns appropriate HTML objects
 * to present the object within the HTML page.
 *
 * Adding child elements is performed by the "add()" method. "add()"
 * appends the elements given as its arguments to the child elements
 * of the instance.  The "add()" method also allows strings, arrays
 * and functions to be passed as children to be added to the array.
 * If an array is given its elements are passed to "add()" to be added 
 * individually.  The elements may be object instances, arrays or functions
 * as per the arguments to "add()".  If a function is passed it is
 * called and its result passed in a recursive call to "add()" on
 * the instance.  The function may return an object instance, array
 * or function as per the arguments to "add()".
 *
 * The above calling semantics give great flexibliity in adding objects.
 * A single invoccation of "add()" is often sufficent to generate a
 * complete page or complex document structure and the use of embedded
 * functions simplifies the dynamic generation of content.
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Element = [class


    /**
     * element = HTML.Element:new(tag, text)
     *
     * Create a new instance of an element.  The arguments are the
     * element's tag and optional body text, both strings.  The new
     * element is created with the given tag and body text and no
     * attributes or children.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(tag, text)
    {
        auto text = "";
        if (!text)
            text = "";
        this = this:^new();
        this.el_tag := tag;
        this.el_attr := struct();
        this.el_children := array();
        this.el_text := text;
        this.el_class := NULL;
        this.el_id := NULL;
        this.el_style := NULL;
        return this;
    }


    /**
     * element = element:output([file])
     *
     * Output an element to the given file or stdout if no file is passed.
     * This method outputs an HTML representation of the element instance
     * to the given stream.  Output is performed in three method calls -
     * "output_head()" to output the start of the element.  Then "output_body()"
     * to output any body text and child elements and finally "output_tail()"
     * to generate the end tag for the element.
     *
     * The method returns the instance to allow method chaining.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output(file)
    {
        if (!file)
            file = stdout;

        this:output_head(file);
        this:output_body(file);
        this:output_tail(file);

        return this;
    }


    /**
     * element:output_head(file)
     *
     * Output the element's start tag and attributes.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_head(file)
    {
        printf(file, "<%s", encode(el_tag));
        this:output_attr(file);
        printf(file, ">");
    }


    /**
     * element:output_attr(file)
     *
     * Output the element's attributes for use in a HTML tag.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_attr(file)
    {
        auto k;
        if (el_class)
            printf(file, " class=\"%s\"", encode(el_class));
        if (el_id)
            printf(file, " id=\"%s\"", encode(el_id));
        if (el_style)
            printf(file, " style=\"%s\"", encode(el_style));
        if (nels(el_attr) > 0)
            forall (k in sort(keys(el_attr)))
                printf(file, " %s=\"%s\"", encode(k), encode(el_attr[k]));
    }


    /**
     * element:output_body(file)
     *
     * Output the element's body and children to the given file.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_body(file)
    {
        printf(file, "%s", encode(el_text));
        auto k;
        forall (k in el_children)
        {
            t := typeof(k);
            while (t == "func" || t == "method")
                t = typeof(k = k());
            if (t == "string")
                printf(file, "%s", encode(k));
            else
                k:output(file);
        }
    }


    /**
     * element:output_tail(file)
     *
     * Output the element's end tag.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_tail(file)
    {
        if (!file)
            file = stdout;
        printf(file, "</%s>", encode(el_tag));
    }


    /**
     * string = element:get_text()
     *
     * Return the element's body text.  If the element has
     * no body text an empty string is returned.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    get_text()
    {
        return el_text;
    }


    /**
     * element = element:text(string)
     *
     * Set the element's body text to the given string.
     * Returns the instance for method chaining.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    text(text)
    {
        el_text = text;
        return this;
    }


    /**
     * element = element:klass(str)
     *
     * Define the class of an element.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    klass(str)
    {
        el_class = str;
        return this;
    }


    /**
     * element = element:id(str)
     *
     * Define the id of an element.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    id(str)
    {
        el_id = str;
        return this;
    }


    /**
     * element = element:style(str)
     *
     * Define a style attribute for an element.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    style(str)
    {
        el_style = str;
        return this;
    }


    /**
     * element = element:add_text(string)
     *
     * Append the given string to the element's body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    add_text(text)
    {
        el_text += text;
        return this;
    }


    /*
     * element = element:add(...)
     *
     * Add child elements to an element.  See the comment at
     * the head of this class for a description of the arguments
     * and semantics of this method.
     *
     * Returns the element instance for method chaining.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    add()
    {
        auto child, vargs = [array];
        forall (child in vargs)
        {
            if ((t := typeof(child)) == "array")
                call(this:add, child);
            else // assume struct or string
                push(el_children, child);
        }
        return this;
    }


    /**
     * array = element:children()
     *
     * Return the array storing the element's children.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    children()
    {
        return el_children;
    }


    /**
     * element = element:attr(name, value)
     *
     * Set the named attribute of the element to the given value.
     * Both name and value are strings.  If the attribute exists
     * it is overwritten, if it does not exist it is created.
     * Returns the element instance for method chaining.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    attr(name, val)
    {
        el_attr[name] = val;
        return this;
    }


    /**
     * string|NULL = element:get_attr(string)
     *
     * Return the value of the named attribute.  Returns NULL
     * if there is no such attribute for this element.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    get_attr(name)
    {
        return el_attr[name];
    }

];


/**
 * HTML.NoEndTagElement  --  internal base-class for elements with no end tag
 *
 * This is a specialisation of HTML.Element that removes overrides output_tail()
 * so no end tag is generated for type of this element.  All other behaviour is
 * the same as HTML.Element.
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
static NoEndTagElement = [class: Element,

    output_tail(file)
    {
    }

];


/**
 * HTML.Markup  --  class to represent arbtirary content
 *
 * The HTML.Markup class provides an escape mecahanism within
 * the structure of HTML.Element based classes.  An HTML.Markup
 * instance stores arbitrary text which is output direct to
 * the output stream.  The intent is to allow any HTML content
 * to be used with this class hierarchy.
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Markup = [class: NoEndTagElement,

    /**
     * element = HTML.Markup:new(string)
     *
     * Create a new element holding the given content data
     * given as argument.  The data is output verbatim
     * during output.  Markup elements allow arbitrary
     * data to be embedded within a document.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        return this:^new(NULL, text);
    }


    /**
     * markup:output_head(file)
     *
     * Override Element:output_head() to do nothing.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_head(file)
    {
    }


    /**
     * markup:output_body(file)
     *
     * Implement Element:output_body() to output our
     * markup content.  We can't use the Element class
     * implementation as we define no concept of children
     * (although we inherit it, the behaviour is nullified
     * by not outputting any child elements).
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_body(file)
    {
        printf(file, "%s", el_text);
    }

];


/**
 * HTML.P  --  HTML paragraph element
 *
 * An HTML.P instance represents a paragraph.  It is a special
 * case of element in that it has no start tag and the end of a
 * paragraph is marked by a sole "<P>" element.  The class
 * overrides the "output_head()" method to remove any start
 * tag and implements "output_tail()" to generate the "<p>".
 * Body output is done by HTML.Element.
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern P = [class: Element,


    /**
     * element = HTML.P:new([string])
     *
     * Create a new HTML paragraph element with the given string
     * as its body.  If no argument is passed the body is the
     * empty string.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        return this:^new("p", text);
    }


    /**
     * p:output_head(file)
     *
     * Override Element:output_head to do nothing.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_head(file)
    {
    }


    /**
     * p:output_tail(file)
     *
     * Implement Element:output_tail() to output the
     * trailing paragraph tag.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_tail(file)
    {
        printf(file, "<p>");
    }

];


/**
 * HTML.Big  --  wrapper element that displays its body text in a larger font
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Big = [class: Element,

    new(text)
    {
        return this:^new("big", text);
    }

];


/**
 * HTML.Small  --  wrapper element that displays its body text in a smaller font
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Small = [class: Element,

    new(text)
    {
        return this:^new("small", text);
    }

];


/**
 * HTML.Cite  --  wrapper element that displays its body text as a citation
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Cite = [class: Element,

    new(text)
    {
        return this:^new("cite", text);
    }

];


/**
 * HTML.Code  --  wrapper element that displays its body text as program code
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Code = [class: Element,

    new(text)
    {
        return this:^new("code", text);
    }

];


/**
 * HTML.Kbd  --  wrapper element that displays its body text as keyboard entered text
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Kbd = [class: Element,

    new(text)
    {
        return this:^new("kbd", text);
    }

];


/**
 * HTML.Strike  --  wrapper element that displays its body text in a strikeout font
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Strike = [class: Element,

    new(text)
    {
        return this:^new("strike", text);
    }

];


/**
 * HTML.Strong  --  wrapper element that displays its body text in a strong style
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Strong = [class: Element,

    new(text)
    {
        return this:^new("strong", text);
    }

];


/**
 * HTML.Typewriter  --  wrapper element that displays its body text in a fixed width font
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Typewriter = [class: Element,

    new(text)
    {
        return this:^new("tt", text);
    }

];


/**
 * HTML.Underline  -- wrapper element that displsus its body text with an underline
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Underline = [class: Element,

    new(text)
    {
        return this:^new("u", text);
    }

];


/**
 * HTML.Font  --  control font presentation
 *
 * An HTML.Font element allows control over the font
 * used by any child elements.  It is a wrapper element
 * to control the presentation of its children.
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Font = [class: Element,

    /**
     * element = HTML.Font:new([string])
     *
     * Create a new Font element with the given body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        return this:^new("font", text);
    }


    /**
     * element = element:face(string)
     *
     * Set the typeface used with a Font element.
     * Returns the element instance to allow for method chaining.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    face(face)
    {
        return this:attr("face", face);
    }


    /**
     * element = element:size(int|string)
     *
     * Set the size of the font defined by the font element.
     * The size may be given as a integer or string.
     * Returns the element instance to allow for method chaining.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    size(size)
    {
        return this:attr("size", string(size));
    }


    /**
     * element = element:color(string)
     *
     * Set the color used when drawing characters with a
     * font element.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    color(c)
    {
        return this:attr("color", c);
    }

];


/**
 * HTML.Bold  --  embolden child element text
 *
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Bold = [class: Element,

    /**
     * element = HTML.Bold:new([string])
     *
     * Create a new Bold element with the given body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        this = this:^new("b", text);
        return this;
    }

];


/**
 * HTML.Italic  --  italicise child element text
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Italic = [class: Element,

    /**
     * element = HTML.Italic:new([string])
     *
     * Create a new Italic element with the given body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        this = this:^new("i", text);
        return this;
    }

];


/**
 * HTML.Address  --  wrapper element that displays its body as an address
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Address = [class: Element,

    /**
     * element = HTML.Address:new([string])
     *
     * Create a new Address element with the given body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        return this:^new("address", text);
    }

];


/**
 * HTML.Em  --  wrapper element that displays its body in a emphasised style
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Em = [class: Element,

    /**
     * element = HTML.Em:new([string])
     *
     * Create a new Em element with the given body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        return this:^new("em", text);
    }

];


/**
 * HTML.Blockquote  --  wrapper element that displays its body as a quote
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Blockquote = [class: Element,

    /**
     * element = HTML.Blockquote:new([string])
     *
     * Create a new Blockquote element with the given body text.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(text)
    {
        return this:^new("blockquote", text);
    }

];


/**
 * HTML.Page  -  a HTML page
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Page = [class: Element,


    /**
     * page = HTML.Page:new([string [, bool]])
     *
     * Create a new HTML.Page instance with the given title string, if any.
     * If the second parameter is passed it can be used to disable the
     * default behaviour that assumes we are running as a CGI program
     * under some HTTP server.  If the flag is passed as false no CGI
     * output is generated.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    new(title, docgi)
    {
        auto docgi = 1;
        auto title = "";
        this = this:^new("body");
        this.page_title := title;
        this.page_headers := array();
        this.page_docgi := docgi;
        this.page_cgiheaders := array();
        if (!docgi)
            this.page_param := struct();
        else
        {
            try
                this.page_param := cgi.form_data();
            onerror
                this.page_param := struct();
        }
        return this;
    }


    /**
     * string|array = page:param(string)
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    param(key)
    {
        return page_param[key];
    }


    /**
     * struct = page:params()
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    params()
    {
        return page_param;
    }


    /**
     * page = page:nocgi([flag])
     *
     * Disable or enable output of CGI headers.  They are enabled by default.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    nocgi(flag)
    {
        auto flag = 1;
        page_docgi = !flag;
        return this;
    }

    /**
     * page = page:title(string)
     *
     * Set the page title.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    title(title)
    {
        page_title = title;
        return this;
    }


    /**
     * page = page:colors(string [, string [, string, [string]]])
     *
     * Define the colors used when rendering the page.  The first
     * argument, the only required argument, defines the page background
     * color.  The second argument is the default color of text, the
     * third argument the default color of links and the final argument
     * the default color of visited links.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    colors(bgcolor, text, link, vlink)
    {
        this:attr("bgcolor", bgcolor);
        if (text)
            this:attr("text", text);
        if (link)
            this:attr("link", link);
        if (vlink)
            this:attr("vlink", vlink);
        return this;
    }


    /**
     * page = page:bgcolor(string)
     *
     * Define the page background color.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    bgcolor(c)
    {
        return this:attr("bgcolor", c);
    }


    /**
     * page = page:text_colors(string [, string, [string]])
     *
     * Define the colors used when drawing text on the page.  The first
     * argument is the default color of text, the second argument the
     * color of text within anchors and the third argument the color
     * of visited links.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    text_colors(text, link, vlink)
    {
        this:attr("text", text);
        if (link)
            this:attr("link", link);
        if (vlink)
            this:attr("vlink", vlink);
        return this;
    }


    /**
     * page = page:add_header(element)
     *
     * Add an element to the header section of the page, i.e, the portion
     * between the <head> and </head> tags.  This is used to add meta tags
     * and the like.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    add_header(h)
    {
        push(page_headers, h);
        return this;
    }


    /**
     * page = page:style(text)
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    style(text)
    {
        this:add_header(Style:new(text));
    }


    /**
     * page:output_head(file)
     *
     * Implement Element:outupt_head() to output the page header
     * before the <body> tag, which is our element's tag in the
     * Element instance.  This outputs the headers defined by
     * by user.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_head(file)
    {
        /* If we're running as a CGI program output the header unless disabled */
        if (page_docgi && getenv("REQUEST_METHOD"))
        {
            call(cgi.start_reply_header, page_cgiheaders);
            cgi.content_type("text/html");
            cgi.end_reply_header();
        }
        printf
        (
            file,
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">"
            "<html><head><title>%s</title>"
            "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">",
            page_title
        );
        auto s;
        forall (h in page_headers)
            h:output(file);
        printf(file, "</head>");
        this:^output_head(file);
    }


    /**
     * page = page:add_cgi_header(name, value)
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    add_cgi_header(nom, val)
    {
        push(page_cgiheaders, nom);
        push(page_cgiheaders, val);
        return this;
    }


    /**
     * page:output_tail(file)
     *
     * Implement Element:output_tail() to output the real
     * end of page tag following the </body> our superclass
     * outputs.
     *
     * This --topic-- forms part of the --ici-HTML-- documentation.
     */
    output_tail(file)
    {
        this:^output_tail(file);
        printf(file, "</html>\n");
    }

];


/**
 * HTML.Style  --  page header style element
 *
 * This --topic-- forms part of the --ici-HTML-- documentation.
 */
extern Style = [class: Element,

    new(text)
    {
        return this:^new("style", text);
    }

];


/**
 * HTML.Hr  -  a horizontal rule, i.e, line
 */
extern Hr = [class: NoEndTagElement,

    new(size, shade)
    {
        auto shade = 1;
        this = this:^new("hr");
        if (size != NULL && size != 0)
            this:attr("size", string(size));
        this.hr_noshade := !shade;
        return this;
    }

    shade(flag)
    {
        auto flag = 0;
        hr_noshade = !flag;
        return this;
    }

    noshade(flag)
    {
        auto flag = 1;
        return this:shade(!flag);
    }

    size(size)
    {
        return this:attr("size", string(size));
    }

    output_attr(file)
    {
        if (hr_noshade)
            printf(file, " noshade");
        this:^output_attr(file);
    }

];


/**
 * HTML.Image  --  an embedded image element
 */
extern Image = [class: NoEndTagElement,

    new(src, alt)
    {
        auto alt = "[Image]";
        this = this:^new("img");
        this.i_ismap := 0;
        this:src(src);
        this:alt(alt);
        return this;
    }

    output_attr(file)
    {
        if (i_ismap)
            printf(file, " ismap");
        this:^output_attr(file);
    }

    src(url)
    {
        return this:attr("src", url);
    }
    
    alt(txt)
    {
        return this:attr("alt", txt);
    }

    align(a)
    {
        return this:attr("align", a);
    }

    border(n)
    {
        return this:attr("border", string(n));
    }

    width(w)
    {
        return this:attr("width", string(w));
    }
    
    height(h)
    {
        return this:attr("height", string(h));
    }

    ismap(flag)
    {
        auto flag = 1;
        i_ismap = flag;
        return this;
    }

    usemap(map)
    {
        return this:attr("usemap", map);
    }

];


/**
 * HTML.Br  --  a forced line break
 */
extern Br = [class: NoEndTagElement,

    new()
    {
        return this:^new("br");
    }

];


/**
 * HTML.Hx  --  internal base class for header elements.
 */
static Hx = [class: Element,

    new(n, header)
    {
        return this:^new(sprintf("h%d", n), header);
    }

];


/**
 * HTML.H1  -- level 1 header.
 */
extern H1 = [class: Hx,

    new(header)
    {
        return this:^new(1, header);
    }

];


/**
 * HTML.H2  -- level 2 header.
 */
extern H2 = [class: Hx,

    new(header)
    {
        return this:^new(2, header);
    }

];


/**
 * HTML.H3  -- level 3 header.
 */
extern H3 = [class: Hx,

    new(header)
    {
        return this:^new(3, header);
    }

];


/**
 * HTML.H4  -- level 4 header.
 */
extern H4 = [class: Hx,

    new(header)
    {
        return this:^new(4, header);
    }

];


/**
 * HTML.H5  -- level 5 header.
 */
extern H5 = [class: Hx,

    new(header)
    {
        return this:^new(5, header);
    }

];


/**
 * HTML.H6  -- level 6 header.
 */
extern H6 = [class: Hx,

    new(header)
    {
        return this:^new(6, header);
    }

];


/**
 * HTML.Pre  --  preformatted text element
 */
extern Pre = [class: Element,

    new(text)
    {
        return this:^new("pre", text);
    }

];


/**
 * HTML.Anchor  --  make element body a hyperlink
 *
 * This a wrapper element that makes its body, including
 * any child elements, a hyperlink to the given URL.
 */
extern Anchor = [class: Element,

    new(url, text)
    {
        this = this:^new("a", text);
        if (url)
            this:attr("href", url);
        return this;
    }

    url(url)
    {
        return this:attr("href", url);
    }

];


/**
 * HTML.UList  --  unlabelled list element.
 *
 * The HTML.UList element presents any HTML.ListItem children
 * in a unlabelled list.
 */
extern UList = [class: Element,

    new()
    {
        return this:^new("ul");
    }

];


/**
 * HTML.OList  --  ordinal list element.
 *
 * The HTML.OList presents any HTML.ListItem child elements
 * within a labelled list.
 */
extern OList = [class: Element,

    new()
    {
        return this:^new("ol");
    }

];


/**
 * HTML.DList  --  ordinal list element.
 *
 * The HTML.OList presents any HTML.ListItem child elements
 * within a labelled list.
 */
extern DList = [class: Element,

    new()
    {
        return this:^new("dl");
    }

];

extern Dt = [class: NoEndTagElement,

    new(text)
    {
        return this:^new("dt", text);
    }
];

extern Dd = [class: NoEndTagElement,

    new(text)
    {
        return this:^new("dd", text);
    }

];


/**
 * HTML.DirList
 */
extern DirList = [class: Element,

    new()
    {
        return this:^new("dir");
    }

];


/**
 * HTML.Menu
 */
extern Menu = [class: Element,

    new()
    {
        return this:^new("menu");
    }

];



/**
 * HTML.ListItem  --  item within a list element.
 *
 * This is wrapper class that makes its body and
 * children an item within a list.
 */
extern ListItem = [class: Element,

    new(text)
    {
        return this:^new("li", text);
    }

];


/**
 * HTML.TableElement  --  internal base class for Table elements.
 *
 * This provides common attribute setting methods.
 */
static TableElement = [class: Element,

    bgcolor(color)
    {
        return this:attr("bgcolor", color);
    }

    width(w)
    {
        return this:attr("width", string(w));
    }

    height(h)
    {
        return this:attr("height", string(h));
    }

    align(where)
    {
        return this:attr("align", where);
    }

    valign(where)
    {
        return this:attr("valign", where);
    }

];


/**
 * HTML.Table  --  a table element.
 */
extern Table = [class: TableElement,

    new(summary)
    {
        auto summary = "";
        this = this:^new("table");
        this:attr("summary", summary);
        return this;
    }

    summary(txt)
    {
        return this:attr("summary", txt);
    }

    border(width)
    {
        return this:attr("border", string(width));
    }

    cellspacing(spacing)
    {
        return this:attr("cellspacing", string(spacing));
    }
    
    cellpadding(padding)
    {
        return this:attr("cellpadding", string(padding));
    }

    newrow()
    {
        r := TableRow:new();
        this:add(r);
        return r;
    }

    newhead(label)
    {
        h := TableHeader:new(label);
        this:add(h);
        return h;
    }

];


/**
 * HTML.TableRow  --  a row within a table.
 *
 *
 */
extern TableRow = [class: TableElement,

    new()
    {
        return this:^new("tr");
    }

    newcell(v)
    {
        c := TableCell:new(v);
        this:add(c);
        return c;
    }

    emptycell(numspaces)
    {
        auto numspaces = 1;
        c := EmptyTableCell:new(numspaces);
        this:add(c);
        return c;
    }

];


/**
 * HTML.TableCell  --  a cell within a table row.
 *
 *
 */
extern TableCell = [class: TableElement,

    new(text)
    {
        return this:^new("td", text);
    }

    colspan(n)
    {
        return this:attr("colspan", string(n));
    }

    rowspan(n)
    {
        return this:attr("rowspan", string(n));
    }
];


/**
 * HTML.EmptyTableCell  --  a cell containing a non-breaking space
 */
extern EmptyTableCell = [class: TableCell,

    new(numspaces)
    {
        auto numspaces = 1;
        this = this:^new();
        while (numspaces-- > 0)
            this:add(NonBreakingSpace);
        return this;
    }

];

/**
 * HTML.TableHeader  --  a table heading cell.
 */
extern TableHeader = [class: TableElement,

    new(label)
    {
        return this:^new("th", label);
    }

    colspan(n)
    {
        return this:attr("colspan", string(n));
    }

];


/**
 * HTML.Form  --  an input form.
 *
 *
 */
extern Form = [class: Element,

    new(action, method)
    {
        auto method = "POST";
        this = this:^new("form");
        this:attr("action", action);
        this:attr("method", method);
        return this;
    }

    action(action)
    {
        return this:attr("action", action);
    }

    method(method)
    {
        return this:attr("method", method);
    }

    hidden_field(key, val)
    {
        return this:add(HTML.HiddenField:new(key, val));
    }

];


/**
 * HTML.InputElement  --  internal base class for input elements.
 *
 */
static InputElement = [class: NoEndTagElement,

    new(typ, nom, val)
    {
        this = this:^new("input");
        this:type(typ);
        this:name(nom);
        this:value(val);
        return this;
    }

    type(typ)
    {
        return this:attr("type", typ);
    }

    name(nom)
    {
        return this:attr("name", nom);
    }

    value(val)
    {
        if (val)
            this:attr("value", val);
        return this;
    }

];


/**
 * HTML.SubmitButton  --  form submission button element.
 *
 */
extern SubmitButton = [class: InputElement,

    new(val, nom)
    {
        auto nom = "submit";
        this = this:^new("submit", nom, val);
        return this;
    }

];


/**
 * HTML.ResetButton  --  form input reset button element.
 */
extern ResetButton = [class: InputElement,

    new(val, nom)
    {
        auto nom = "reset";
        this = this:^new("reset", nom, val);
        return this;
    }

];


/**
 * HTML.InputImage
 */
extern InputImage = [class: InputElement,

    new(nom, url)
    {
        this = this:^new("image", nom);
        return this:set_src(url);
    }

    set_src(url)
    {
        return this:attr("src", url);
    }

    align(a)
    {
        return this:attr("align", a);
    }

    border(n)
    {
        return this:attr("border", string(n));
    }

];



/**
 * HTML.TextField  --  a text field form element
 *
 */
extern TextField = [class: InputElement,

    new(name, val, size, maxlength)
    {
        auto val = "";
        this = this:^new("text", name, val);
        if (size)
            this:attr("size", string(size));
        if (maxlength)
            this:attr("maxlength", string(maxlength));
        return this;
    }

];


/**
 * HTML.PasswordField  --  a password field form element
 */
extern PasswordField = [class: InputElement,

    new(name, val, size, maxlength)
    {
        auto val = "";
        this = this:^new("password", name, val);
        if (size)
            this:attr("size", string(size));
        if (maxlength)
            this:attr("maxlength", string(maxlength));
        return this;
    }

];


/**
 * HTML.CheckedInputElement  --  an input element that supports "checking"
 */
static CheckedInputElement = [class: InputElement,

    new(type, name, val, checked)
    {
        this = this:^new(type, name, val);
        this.cie_checked := checked;
        return this;
    }

    checked(flag)
    {
        auto flag = 1;
        cie_checked = flag;
        return this;
    }

    is_checked()
    {
        return cie_checked;
    }

    output_attr(file)
    {
        this:^output_attr(file);
        if (cie_checked)
            printf(file, " checked");
    }

];


/**
 * HTML.Checkbox  --  checkbox form element.
 */
extern Checkbox = [class: CheckedInputElement,

    new(name, checked, val)
    {
        return this:^new("checkbox", name, val, checked);
    }

];


/**
 * HTML.HiddenField  --  an invisible form element
 */
extern HiddenField = [class: InputElement,

    new(name, val)
    {
        auto val = "";
        return this:^new("hidden", name, val);
    }

];


/**
 * HTML.TextArea  --  multi-line text input field
 */
extern TextArea = [class: Element,

    new(name, text)
    {
        this = this:^new("textarea", text);
        this:attr("name", name);
        return this;
    }

    rows(n)
    {
        return this:attr("rows", string(n));
    }

    cols(n)
    {
        return this:attr("cols", string(n));
    }

];


/**
 * HTML.Radio  --  a member of radio button group
 */
extern Radio = [class: CheckedInputElement,

    new(name, text, val, checked)
    {
        return this:^new("radio", name, val, checked);
    }

];


/**
 * HTML.FileSelector  --  a file selector form element
 */
extern FileSelector = [class: InputElement,

    new(name, val)
    {
        return this:^new("file", name, val);
    }

];


/**
 * HTML.IsIndex  --  simple search field
 */
extern IsIndex = [class: NoEndTagElement,

    new(prompt)
    {
        this = this:^new("isindex");
        if (prompt)
            this:attr("prompt", prompt);
        return this;
    }

    prompt(str)
    {
        return this:attr("prompt", str);
    }

];


/**
 * HTML.SelectList  --  select list
 */
extern SelectList = [class: Element,

    new(name, size, mult)
    {
        this = this:^new("select");
        this:attr("name", name);
        if (size)
            this:size(size);
        this.s_multiple := mult;
        return this;
    }

    output_attr(file)
    {
        if (s_multiple)
            printf(file, " multiple");
        this:^output_attr(file);
    }

    multiple(flag)
    {
        auto flag = 1;
        s_multiple = flag;
        return this;
    }

    size(n)
    {
        return this:attr("size", string(n));
    }

];


/**
 * HTML.Div  --  a division
 */
extern Div = [class: Element,

    new(text)
    {
        return this:^new("div", text);
    }

    align(a)
    {
        return this:attr("align", a);
    }

];


/**
 * HTML.SelectOption  --  an option within a select list
 */
extern SelectOption = [class: Element,

    new(val, text)
    {
        this = this:^new("option", text);
        this.o_selected := 0;
        return this:value(val);
    }

    value(val)
    {
        return this:attr("value", val);
    }

    selected(flag)
    {
        auto flag = 1;
        o_selected = flag;
        return this;
    }

    output_attr(file)
    {
        if (o_selected)
            printf(file, " selected");
        this:^output_attr(file);
    }

];


/**
 * HTML.Entity  --  class to represent embedded HTML "entities"
 *
 * An entity is a named character glyph with a specific representation
 * within HTML  --  "&" <name> ";".  This class implements the element
 * output protocol to allow entities to be used as child elements.
 */
extern Entity = [class

    new(what)
    {
        this = this:^new();
        this.e_what := what;
        return this;
    }

    output(file)
    {
        printf(file, "&%s;", e_what);
    }

];


/**
 * Commonly used entities.
 */
extern Ampersand    = Entity:new("amp");
extern GreaterThan  = Entity:new("gt");
extern LessThan     = Entity:new("lt");
extern NonBreakingSpace = Entity:new("nbsp");
extern CopyrightSymbol  = Entity:new("copy");
extern TrademarkSymbol  = Entity:new("trade");
extern RegisteredTrademarkSymbol = Entity:new("reg");


/*
 * $Log: ici4HTML.ici,v $
 * Revision 1.5  2003/06/09 07:56:50  atrn
 * Use new cgi module i/face and make encode() more ici4HTML.ici
 * forgiving of NULLs
 *
 * Revision 1.4  2003/04/15 07:06:19  atrn
 * Use 0 and 1 rather than true and false.
 *
 * Revision 1.3  2003/02/24 21:06:07  timl
 * Corrected name of HTML doc files.
 *
 * Revision 1.2  2003/01/30 13:00:59  timl
 * Added comment tags in html module and upgraded the Win32 installer.
 *
 * Revision 1.1  2003/01/27 10:51:03  atrn
 * First cut at conversion for ici 4 and new configure
 *
 * Revision 1.12  2002/06/06 03:41:21  atrn
 * Allow caller of row's emptycell() to specify the number
 * of non-breaking space elements (spacing hack).  Added
 * a border() method for input image elements.
 *
 * Revision 1.11  2002/05/23 00:44:40  atrn
 * Added emptycell() method to TableRow class for simpler
 * addition of empty cells to table rows (obviously).
 *
 * Revision 1.10  2002/05/23 00:29:26  atrn
 * Added EmptyTableCell for simpler addition of blank cells
 *
 * Revision 1.9  2002/03/13 04:40:28  atrn
 * Add trademark entities
 *
 * Revision 1.8  2002/01/27 20:54:18  atrn
 * Added support for other types of lists, a method to get all the query
 * string parameters, add a character encoding spec. to the document
 * header, a method for creating hidden fields in tables, allow submit
 * and reset button values to be set and remove old ImageInput class.
 *
 * Revision 1.7  2002/01/26 07:18:20  atrn
 * Added CGI support, turned on by default but controllable at Page:new()
 * time.  CGI support includes automatic output of CGI headers when a
 * page element is output and support for CGI query strings via the
 * page:param() method.  Added HTML.Div() class for divisions.
 *
 * Revision 1.6  2002/01/26 05:54:45  atrn
 * Delay calling of functions, or methods, added as children until the
 * containing element is output.  Added support for "image" input
 * elements, <INPUT TYPE="IMAGE"...>.
 *
 * Revision 1.5  2002/01/25 23:27:04  atrn
 * Added bgcolor() and text_colors() methods to HTML.Page to complement
 * the existing page:colors() method.  Bgcolor() is there to match other
 * elements and text_colors() to complement it.  Colors() still exists
 * to set them all in one shot.
 *
 * Revision 1.4  2002/01/22 05:33:52  atrn
 * Added a value to CheckedInputElement and added this to Checkbox.
 *
 * Revision 1.3  2002/01/21 03:49:29  atrn
 * Removed the HTML.Text class and implemented the functionality by
 * allowing strings as element children.  These are encoded and output
 * as per other user-supplied text.
 *
 * Revision 1.2  2002/01/21 03:42:57  atrn
 * Added the HTML.Text class for embedding textual content as a child of
 * an element.  Unlike HTML.Markup elements this text is HTML encoded.
 *
 * Revision 1.1  2002/01/20 01:57:24  atrn
 * Added class-based HTML page generation module.
 *
 */

/*
 * For x?emacs...
 * Local Variables:
 * mode:c
 * c-basic-offset:8
 * tab-width:8
 * End:
 */
